%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-*-LaTeX-*-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%%     standard texheader fo writing extended documents
%%%
%%%  
%%%
%%%
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%**** header *****%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[paper=A4, pagesize, DIV=calc, smallheadings,
fontsize=11pt, expansion=false]{scrreprt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%### used packages ###%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%# standardmaessig verwendbar #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage[ngerman]{babel}      %% neue deutsche Rechtschreibung
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}    
\usepackage{graphicx}            %% include graphics
\usepackage{float}               %% determine image positions
\usepackage{soul}             %% offers additional types of text formation
                                 %% HAS TO BE INSTALLED MANUALLY
\usepackage{ellipsis}         %% HAS TO BE INSTALLED MANUALLY
\usepackage{xspace}             
\usepackage{tabularx}             %% tables
\usepackage[font={footnotesize}]{caption}%% description of images and tables 
\usepackage{booktabs}            %% formatting of tables
\usepackage{rotating}            
\usepackage{multirow}
\usepackage{geometry}            %% page geometry 
\usepackage{scrpage2}            %% page layout
\usepackage{dsfont}              %% math font \mathds{R}, => "Real Numbers"                 
\usepackage{natbib}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[linkbordercolor={0 0 1}]{hyperref} %% links
\usepackage{color}
\usepackage{allrunes}
\usepackage{comment}
\usepackage[expansion=false]{microtype} %% for pdfTeX 1.4 or later
\usepackage{wasysym}


\geometry{
   a4paper,
  twoside,
%% paperheight=xxx,
%% paperwidth=xxx,
%%   outer=20mm,
%%   inner=25mm,
  left=30mm,
  right=25mm,
   top=25mm,
   bottom=30mm
%   includefoot
}

\clearscrheadfoot %% clear all 6 column fields
\pagestyle{scrheadings} 
\cfoot[\pagemark]{\pagemark}
\setheadwidth{text}
\setheadsepline[text]{0.3mm}
\ohead{\headmark}
\automark[chapter]{chapter}
\renewcommand{\headfont}{\bfseries}

%%%%%%%%%% Crystallographic Symbols %%%%%%%%%%%%%%%%%%%%%%%%%
%%% Needs the font cryst.pfb installed
%%% Symbol is created by \cry{xxx}
\DeclareFontFamily{U}{cry}{\hyphenchar\font=-1}
\DeclareFontShape{U}{cry}{m}{n}{ <-> cryst}{}
\newcommand{\cry}[1]{{\usefont{U}{cry}{m}{n} \symbol{#1}}}

%%%%%%% linestretch and indent of paragraphs 
\renewcommand{\baselinestretch}{1.15}
\parindent0pt

\newenvironment{packed_item}{
\begin{itemize}
  \setlength{\itemsep}{0pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{itemize}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%### macros ###%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\latex}{\LaTeX\xspace}  %% \latex for "LaTeX"
\newcommand{\tex}{\TeX\xspace}      %% \tex for "TeX
\renewcommand{\contentsname}{Contents}
\renewcommand{\bibname}{References}
\newcommand{\overbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}
\newcommand{\forceindent}[1]{\leavevmode{\parindent=#1\indent}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%***** Document *****%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%***Title page(s)***%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagestyle{empty}
\huge
\begin{center}
\textbf{Introduction into C++}\\
\Large
\textbf{Programming course at the University of Konstanz, summer term 2018}\\
\large{Ex}
\end{center}
\normalsize
\textit{All exercises can be solved by using constructs of the specifice chapter. 
You may work together on the solutions, however, for getting comfortable with the C++ syntax, everyone should work on his own 
implementation. Please don't use any other special characters than the underscore for the filenames of your solution (especially no space ord minus) and keep the stated formatting of the filename.
Your source code and the comments should always be written in english.
Difficult exercises are guarded by dangerous animals and can be left out. 
\\
Have fun!
}\\
\vspace{2em}\hspace*{30em}
\includegraphics[width=0.1\linewidth]{./imgs/Caffeine.png}
\large
%Übungen (Stichworte Eingabe, Ausgabe, Arithmetik);
\normalsize
%\subsubsection*{Konsolen-Ausgabe, Eingabe, einfache Arithmetik}
\subsubsection*{IPO on bash, arithmetics}
%\begin{enumerate}
%\setcounter{enumi}{-1}
\textbf{0.} 
Play around with the bash commands to get used to it. If there is no emacs reference card in your home folder, you can find it on the internet.
\vspace{.5em}
\\
Write a program, that\\
\textbf{1.} 
 reads two integers from the command line, calculates sum, difference, product and quotient and returns the results.
\begin{verbatim}
  ("Ex1_YourName.cpp")
\end{verbatim}

\textbf{2.}
 swaps the values of two variables $m$ and $n.$
\begin{verbatim}
  ("Ex2_YourName.cpp")
\end{verbatim}

\textbf{3.}
converts temperatures from  $\,^{\circ}\mathrm{C}$ to K and  $\,^{\circ}\mathrm{F}$.
\begin{verbatim}
  ("Ex3_YourName.cpp")
\end{verbatim}

\textbf{4.} 
 asks for volume, concentration and molecular weight
das aus Volumen, Konzentration und Molekulargewicht berechnet, wieviel du auf der Waage einwiegen musst, um eine Lösung dieses Volumens und mit dieser Konzentration herzustellen.
\begin{verbatim}
  ("Ex4_YourName.cpp")
\end{verbatim}

\textbf{5.} 
that calculates the wavelength for a energy state transition of a hydrogen atom via the Rydberg formula (Bohr model):
Remember:  
  \[\frac{1}{\lambda} = R \left( \frac{1}{m^2} - \frac{1}{n^2}\right), R = 10967758,4 10 m^{-1} \]
\textit{Tip: use \textup{\texttt{double}} as data type, otherwise it will be difficult to calculate the fractions correctly.
, sonst wird es schwierig, die Brüche zu berechnen. As we have not learned using exponential functions now,  $m^2=m \cdot m$!}
\begin{verbatim}
  ("Ex5_YourName.cpp")
\end{verbatim}


\textbf{6.}
 $N$ hungry \emph{Paramecia caudata} have been mixed with a culture of \emph{S. cerevisia} consisting of $10^{12}$.
We assume that each Paramecium eats 15 yeast cells per hour and each cell that was not eaten will divide every 2 hours.
How many yeast cells will be left in dependency of $N$? Why do you have to care about the choice of the data types for the size of 
the yeast culture and the amount of Paramecia?\newline
\small
(We assume additionally that the yeast reproduces only asexually by pullulation and no a/$\alpha$-mating takes place).
\begin{verbatim}
  ("Ex6_YourName.cpp")
\end{verbatim}


\subsubsection*{if-branching, number systems}
\textbf{7.}
Write a program, that recognizes the octants for
 3D coordinates (\texttt{double x}, \texttt{double y}, \texttt{double z} for an euclidean system. 
If this is too complicated, start with 4 quadrant in a plane system.
\begin{verbatim}
  ("Ex7_YourName.cpp")
\end{verbatim}

\textbf{8.} 
Develop a converter to write the bit pattern of an \texttt{unsigned char}.
You can try both directions, but starting from the least significant bit will be a bit easier.\\
(Tip: You can use an \texttt{unsigned char} like a non-negative 8-bit integer and use all arithmetic
operators.)
\begin{verbatim}
  ("Ex8_YourName.cpp")
\end{verbatim}



\begin{minipage}[H]{0.3\linewidth}
\includegraphics[width=\textwidth]{./imgs/lion.png}
%\caption{default}
\end{minipage}
\begin{tabular}{m{30em}}
\textbf{9.} 
Decide, whether a line with an offset ($o_x, o_y, o_z$) and direction ($d_x, d_y, d_z$) intersects a spherical surface
with $r$ center ($m_x, m_y, m_z$) and, if so, calculate the intersection points.
\begin{verbatim}
  ("Ex9_YourName.cpp") 
\end{verbatim}
\end{tabular}



\subsubsection*{loops, visibility scopes of local variables} 
\textbf{10.} Write a program that prints uneven numbers from 1 to $n$.
\begin{verbatim}
  ("Ex10_YourName.cpp")
\end{verbatim}



\textbf{11.} Decide whether a number is prime or not.
\begin{verbatim}
("Ex11_YourName.cpp")
\end{verbatim}

\newpage
\textbf{12.} How many times is the body of the following loops executed?
\scriptsize
  \begin{verbatim}
int n = 100;
for(int i = 0 ; i < n; i = i + 1){
  // any source code
}

for(int i = 1 ; i <= n; i = i + 1){
  // any source code
}

for(int i = 0 ; i <= n; i = i + 1){
  // any source code
}

for(int i = 1 ; i < n; i = i + 1){
  // any source code
}

for(int i = 1 ; i < n; i = i + 1){
 i = i+1;
}

for(int i = 0 ; i < n; i = i + 1){
  if(i < 50)
    {
      i = i+1;
    }
}

for(int i = 0 ; i < n; i = i + 1){
  if(i < 51)
    {
      i = i+1;
    }
}

for(int i = 0 ; i < n; i = i + 1){
  if( (i % 3) == 0 )
    {
      i = i+1;
    }
}
\end{verbatim}
\normalsize\newpage
Indicate all visible variables for each $\{$-bracket.
\scriptsize
\begin{verbatim}

#include <iostream>
using namespace std;

int main(){
  int a;  
  double x,y;
  {
    unsigned long long int b;
    int cat =  b % a;
    if(cat < b)
      {
        double z = x + y * b;        
        cout <<  z;
      }
    else if(cat < a)
      { // cat, b, a, x, y
        char chemistry = 'c';
        bool badScientist;
        bool bioHazard = (badScientist = true);
        if(bioHazard && badScientist)
          {
            long long int bigExplosion = 50000000000;
            x += y;
            cout << x;
          }
        else 
          {
            x = 6;
            double captainPicard = cat;
            /*
            {
            Influence?
            }
            */
          }     
        bool unlucky = false;
      }
    else
      {
        a = (int) x - y;
      } 
  }  
}
\end{verbatim}


\newpage
\subsubsection*{Funktionen, Arrays}
\normalsize
\textbf{13.} Enjoy the nice weather and become acquainted with the fancy foods of bavarian beer garden culture.
\begin{center}
  \includegraphics[width=0.4\linewidth]{./imgs/bavFlag.jpeg}
\end{center}



\textbf{14.} Write a program to count from 1 to $N$, but replace
  \begin{itemize}
  \item numbers divisible by 7 by ``Brezn'',
  \item numbers containing the cipher 7 (decimal system) by ``Obazda'',
  \item each repdigit with ``Bier''.
  \end{itemize}
  If severeal conditions are fulfilled, all words should appear in the program output.
  Implement and use the following functions:
\begin{verbatim}
   bool isDivisableByN(int val, int n); 
   bool containsCipherN(int val, int n);
   bool isRepdigit(int val);
\end{verbatim}
Use them like the following:
\begin{verbatim}
   if(isDivisableByN(i, j) {
      //...
   }
   else {
      //...
   }
\end{verbatim}
  \Large
  \textbf{Spoiler:} \\
  \tiny
  \emph{Brew beer by making use of cutting by cutting divsion und mod(n, 10) operations} 
  \normalsize
\begin{verbatim}
("Ex14_YourName.cpp")
\end{verbatim}


\newpage
\begin{minipage}[H]{0.3\linewidth}
\includegraphics[width=\textwidth]{./imgs/schlange}
%\caption{default}
\end{minipage}
\begin{tabular}{m{30em}}
\textbf{15.} 
Calculate the (real) sine tranform  $S(\omega)$ from $1 - 500$ kHz for an  array of \texttt{double} $f(t)$ with a length of 1000 and the unit 1 ms (values 1.0, 2.0, 3.0, ... , 1000.0) with a sampling rate of 100 MHz:
\end{tabular}
  \[ S(\omega)) = \mathcal{SIN}(f(t))  = \sum_{i=0}^{999} f(t) \sin{(2 \pi \omega t_i)}\]
  \emph{Advice: the function \texttt{sin()} ist declared in } \texttt{\textless cmath\textgreater}.\\
  Example:
  \texttt{double sinOfX = sin(x);}\\
  Why would it be wrong to choose a bigger frequency range?
\begin{verbatim}
("Ex15_YourName.cpp")
\end{verbatim}
  
  \textbf{16.}
  Let's assume a 2D-Coordinatesystem with positive axes, where white points are marked by \texttt{true} and blue points by \texttt{false}.
  Build such a coordinate with a length of 101, make all points white and put a blue square in the midde (length $N$, $N < 21$).\\
  Other possibility (difficult):  Draw a real bavarian  aus 1 und 0).
\begin{verbatim}
("Ex16_YourName.cpp")
\end{verbatim}



\textbf{17.} Build a list of function prototypes, to program a variant of ``minesweeper on commandline''. 
Dont't implement the functions, but think about the data types for arguments and return values.\\

\begin{minipage}[H]{0.3\linewidth}
  \includegraphics[width=\textwidth]{./imgs/Hai}
  % \caption{default}
\end{minipage}
\begin{tabular}{m{30em}}
  \textbf{18.}
Build a converter to print a representation of a decimal number in an $n$ number system ($n < 37$).
 Baue einen Konverter, der für positive Zahlen aus dem Dezimalsystem eine Darstellung in einem $n$-Zahlensystem ($n < 37$) ausgeben kann.
\begin{verbatim}
("Ex18_YourName.cpp")
\end{verbatim}
\end{tabular}






\newpage
\subsubsection{Algorithms}
\textbf{19. Bubblesort}
Implement a function
\begin{verbatim}
    void printArray(double data[], unsigned int dataLength);
\end{verbatim}
that writes an array to the command line.
Überlege dir dann ein Verfahren, um eine Funktion mit dem Prototyp
\begin{verbatim}
    unsigned int sortArray(double data[], int dataLength, bool ascending);
\end{verbatim}    
zu implementieren.
  Die Funktion soll das array in auf- oder absteigender Reihenfolge (in Abhängigkeit von \texttt{ascending}) sortieren und ausgeben, wieviele elementare Tauschoperationen insgesamt nötig waren.
  Schreibe dazu eine Funktion
\begin{verbatim}
  unsigned int maxSwapsOfBubbleSort(unsig dataLength);
\end{verbatim}
  Diese soll berechnen, wieviele Tauschoperationen eine Implementierung maximal benutzen muss, um ein array mit der Länge \texttt{dataLength} und unbekanntem Inhalt zu sortieren.

\begin{verbatim}
("Ex18_YourName.cpp")
\end{verbatim}


\textbf{20. Intervallhalbierungsverfahren}\\
  Die Gleichung $ y = x2^x$ ist nicht analytisch nach x auflösbar, d.h. es gibt keinen eindeutigen Ausdruck 
$x = \dots$, der durch Einsetzen von $y$ einen Wert für $x$ liefert. 
Anders ausgedrückt, existiert keine Umkehrfunktion für $f:x \longrightarrow f(x), f(x) = x2^x$.
 Da die Funktion streng monoton ist, kann allerdings durch geschicktes Ausprobieren dennoch einen Wert näherungsweise 
für ein gegebenes $y_{input}$ berechnet werden.\\
Dazu werden eine obere Grenze für $x_{max}$ Grenze für $x_{min}$ definiert 
und das arithmetische Mittel $\overbar{x} = \frac{x_{max} + x_{min}}{2}$ (d.h. die Mitte des Intervalls) in die Gleichung eingesetzt:
\[y_{test} = \overbar{x} * 2^{\overbar{x}}\]
Durch Vergleich des $y_{test}$ mit $y_{input}$ kann nun festgestellt werden, ob der geratene Wert 
$y_{test}$ zu groß oder zu klein war. Dementsprechend wird nun die obere oder untere Grenze angepasst und auf den Wert der Mitte gesetzt. 
Dadurch schrumpft das Intervall und die gesuchte Zahl wird immer weiter eingeschränkt.\\
\textbf{Aufgabe:} Schreibe ein Programm, das 50 solche Iterationen durchführt, um bei obiger Gleichung $x$ für Eingaben $0 \le y \le 10^8$ näherungsweise zu berechnen.
\normalsize
\begin{verbatim}
  ("Ex20_YourName.cpp")
\end{verbatim}    
\textbf{21. Naive Suche auf C-Strings} \\
  Ein C-String ist ein nullterminiertes array von chars, d.h. das letzte Element des arrays hat den Wert 0x00;
  C-Strings können folgendermaßen initialisiert werden:
  \begin{verbatim}
  char c[33] = "For the induction we used IPTG.\n";
\end{verbatim}
  Jede Position enthält dabei ein Zeichen:\\
\begin{center}
\begin{tabular}[H]{|c|c|c|c|c|c|c|c|c|c|}
\hline
Pos  & c[0]          & c[1]          & c[2]          & c[3]           & $\hdots$ & c[29]        & c[30]        & c[31]                       & c[32]                       \\ \hline
char & \texttt{'F'}  & \texttt{'o'}  & \texttt{'r'}  & \texttt{' '}   & $\hdots$ & \texttt{'G'} & \texttt{'.'} & \texttt{'\textbackslash n'} & \texttt{'\textbackslash 0'} \\ \hline
hex  &  0x46         & 0x6F          & 0x72          & 0x20           & $\hdots$ & 0x47         & 0x2E         & 0x0A                        & 0x00                        \\ \hline
\end{tabular}\vspace{0.5ex}
\end{center}
Dabei ist zu beachten, dass immer Platz für das byte 0x00 am Ende mitreserviert wird. Die Länge des arrays muss also immer mindestens $n+1$ betragen, wenn der C-string $n$ chars besitzt (inklusive Sonderzeichen wie '\texttt{\textbackslash n'}\\
\textbf{Aufgabe:} Finde in der Gensequenz bei dem mitgeschickten Programmfragment die Startpositionen alle TATA-Boxen ("TATAA"), indem du die Zeichenfolge "TATAA"~ mit allen möglichen Positionen abgleichst.
\vspace{-1ex}
\begin{verbatim}
  ("Ex21_YourName.txt")
\end{verbatim} 

 \textbf{22. Euler-Verfahren}\\
  Die Kinetik einer Reaktion $ A\longrightarrow B + C$ wird, 
unter der Annahme, dass das Edukt vollständig reagiert, durch die Gleichung 
\[v(t) = \frac{-d[A]}{dt} = k \cdot [A](t) \]
beschrieben. Will man den Verlauf der Konzentrationen berechnen,
 \emph{ohne} dabei die Differentialgleichung durch Variablenseparation und Integration zu lösen,
 kann man dazu ein einfaches iteratives Verfahren anwenden:\\ 
Aus
\[ - \frac{d[A]}{dt} = \frac{d[B]}{dt} = \frac{d[C]}{dt} = k \cdot [A](t) \] 
kann durch einfaches Umstellen
\[d[A] = - k \cdot [A](t) dt ~~~~~\mathrm{und}~~~~~ d[B] = k \cdot [A](t) dt \] 
abgeleitet werden. In einer Näherung kann davon ausgegangen werden, dass die Konzentration von $A$
sich in sehr kleinen Zeitabständen $\Delta t$ praktisch konstant ist. Durch die Diskretierung des Zeitdifferentials folgt also in der Näherung
\[\Delta[A]_{\hat{t}} = - k \cdot [A]_{\hat{t}} \Delta t ~~~~~ \mathrm{und} ~~~~~ \Delta[B]_{\hat{t}} = k \cdot [A]_{\hat{t}} \Delta t \] 
für diskrete Zeiten $\hat{t}$ (Diskrete Zeiten sind z.B. 0 ms, 1 ms, 2 ms, 3 ms,... statt einer kontinuierlichen Zeitachse).
Damit kann die Konzentration zu einem Zeitpunkt $\hat{t}$ wie folgt angegeben werden:
\[ [A]_{\hat{t}} =  [A]_{\hat{t}-1}  - [A]_{\hat{t}-1} \cdot k \cdot \Delta t) = [A]_{\hat{t}-1} \cdot (1 - k \cdot \Delta t)  \] 
\[ [B]_{\hat{t}} = [B]_{\hat{t}-1} + [A]_{\hat{t}-1} \cdot k \cdot \Delta t \]
\textbf{Aufgabe:} Berechne den Konzentrationsverlauf über 1 Minute von $A$ und $B$, mit beliebigem $k$ und Startkonzentration von $A$ und $\Delta t$-Abständen von 50 ms. Kennt man also die Startkonzentration $[A]_{0 ms}$, kann damit $[A]_{10 ms}$ berechnet werden, damit dann $[A]_{20 ms}$ usw.
Mit $>$ kann die Ausgabe der Konsole in ein Textfile umgeleitet werden, d.h. alles was mit cout geschrieben wird, steht danach stattdessen in einer Datei
\begin{verbatim}
$./myProgram > outputFile.txt
\end{verbatim}
Eine entsprechend formatierte Ausgabe kann von einer Tabellenkalkulation oder einem Plotter eingelesen werden (z.B. als csv):
\begin{verbatim}
t,A,B
0,500,0
10,498.6534,0.13473
.............
\end{verbatim}

\textbf{Hinweis:} Das Programm ist iterativ leichter verständlich, auch wenn für die Berechnung eine Rekursionsgleichung angegeben ist.
\begin{verbatim}
  ("Ex22_YourName.txt")
\end{verbatim} 


\begin{minipage}[H]{0.3\linewidth}
\includegraphics[width=\textwidth]{./imgs/vogelspinne}
%\caption{default}
\end{minipage}
\begin{tabular}{m{30em}}\textbf
{23. Graphen und Netzwerkanalyse}\\
Ein Graph ist eine fundamentale Datenstruktur, die überall dort Anwendung findet, wo 
 Beziehungen zwischen diskreten Einzelobjekten, Datensätzen oder anderen Entitäten untersucht werden.
 Formal handelt es sich bei einem Graph um ein Paar $G(V, E)$ mit einer Menge aus Knoten (``vertices'') $V$ und einer Menge aus Kanten $E$.\end{tabular}
Hierbei können die Knoten beispielsweise Städte, Menschen, Publikationen, Wirtschaftssubjekte, Atome, Elektronikbauteile, Akupunkturpunkte usw. darstellen. Die Kanten symbolisieren dann dementsprechend Reiserouten, Bekanntschaften, Zitationen, Transaktionen, Bindungen, Leiterbahnen oder
(für TCM-Esoteriker) Meridiane.\\
\begin{center}
\includegraphics[width=0.3\linewidth]{./imgs/graph} 
\end{center}
Um einen Graphen direkt objektorientiert darzustellen, werden weitere Sprachkonstrukte benötigt. 
Daher bilden wir die Information über die Topologie des Graphen aus dem Bild in einer Adjazenzmatrix $\textbf{A(G)}$ ab. Dabei handelt es sich um eine ``Knoten-mal-Knoten''-Matrix der Form, in der angegeben wird, ob zwei Knoten mit einer Kante verbunden sind.

$\textbf{B}(G)$

\hspace{4em}
\[ \mathbf{A}(G) = \left( \begin{array}{ccccccc}
0 & 1 & 0 & 1 & 0 & 0 \\
1 & 0 & 1 & 1 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 \\
1 & 1 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 \\
    \end{array} \right) \qquad
\mathbf{B}(G) =  \left( \begin{array}{cccccccc}
1 & 0 & 0 & 1 & 0 & 0 & 0 \\
1 & 1 & 1 & 0 & 0 & 0 & 0 \\  
0 & 1 & 0 & 0 & 0 & 1 & 0 \\   
0 & 0 & 1 & 1 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 1 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\end{array}
\right)
\]

Das Konzept des Graphen kann um diverse Eigenschaften erweitert werden (gerichtete Kanten, Farbkanten, Hypergraphen usw.).\\
\textbf{Aufgaben:} 
Erstelle einen Graphen mit $n$ Knoten ($n = 200$) als Adjazenzmatrix. 
Definiere eine Wahrscheinlichkeit $0 < p < 1$, mit der entschieden wird, ob es zwischen 
Ermittle empirisch, wie hoch die Wahrscheinlichkeit $q$ ist, dass jeder Knoten von einem anderen Knoten aus über die Kanten erreich werden kann (d.h. das alle Knoten miteinander zumindest indirekt miteinander verbunden sind) und plotte $q(p)$.

\begin{verbatim}
  ("Ex23_YourName.txt")
\end{verbatim} 

\subsubsection{Pointer, Arrays}

\textbf{24. Pointerarithmetik}

Betrachte folgenden Ausschnitte aus einem Programm:
    \begin{enumerate}
     \item
\begin{verbatim}
int start = 0;
int *startAdress = &start;
cout << startAdress << "\n"; // delivers 0x10000000
startAdress += 0x100;
cout << startAdress << "\n"; // 1
for (int i = 0; i < 16; i++) startAdress += 0x100;
cout << startAdress << "\n"; // 2
--startAdress;
cout << startAdress << "\n"; // 3
\end{verbatim}
    Welche Werte liefert cout bei 1, 2, und 3, unter der Annahme, dass beim ersten cout die Ausgabe im Kommentar erscheint?
  \item
\begin{verbatim}
  unsigned int startValues[5] = {0x0, 0x0, 0x0000FFFF, 0x0, 0x0};
  unsigned int *ptr = startValues + 2;
  cout << *(ptr) << "\n"; // 1
  char *strangePointer = (char*) ptr;  
  strangePointer++; 
  cout << *((unsigned int*) strangePointer) << "\n"; // 2
  strangePointer = strangePointer - 2;
  cout << *((unsigned int*) strangePointer) << "\n";  // 3
\end{verbatim}
    Welche Werte liefert jeweils cout und warum?
  \end{enumerate}
\begin{verbatim}
  ("Ex24_YourName.txt")
\end{verbatim}  

\textbf{25. Bootstrapping}\\
Durch einen extraterrestrischen EMP-Angriff im Jahre 2377 n.Chr. wurden sämtlichen informationsverarbeitenden Systeme auf der Erde zerstört. Der Inhalt sämtlicher Festplatten und Speicher sind unwiderruflich verloren.
Lediglich in den Tiefen eines Militärbunkers der Weltregierung finden sich noch ein paar antike Bauteile, mit denen ein paar Prototypen erfolgreich rekonstruiert werden können.
Nach dem ein minimales Betriebssystem in Maschinensprache etabliert wurde, soll als nächstes ein erster C-Compiler entwickelt werden, um die Informationstechnik der Zivilisation wieder aufzubauen. Dabei stellt die Menschheit fest, dass bei der Compilerkonstruktion um ein Henne-Ei Problem handelt, da der Compilercode selbst ja noch nicht kompiliert werden kann.\\
Zunächst wird also nur ein  Teil eines Sprachstandards als Binärcode bzw. Assembler entwickelt. Mit dieser minimalen Hochsprache kann dann ein Compiler gebaut werden, der schon das ein oder andere Sprachelement mehr kennt. Dieser Zyklus wird fortgeführt, bis der Compiler alle Eigenschaften des Sprachstandards verarbeiten kann.
In der Entwicklugsphase stehen dem Entwickler also nur begrenzte Sprachmittel zur Verfügung.
\textbf{Aufgabe:} Implementiere eine Funktion 
\begin{verbatim}
char charAt(char *cArr, uint cArrSize, uint pos);
\end{verbatim}
Die aus einem char-Array ein bestimmtes Element an der Position \texttt{pos} liest, ohne dabei den Zugriffsoperator \texttt{[]} zu verwenden.
Baue dann damit eine Funktion
\begin{verbatim}
void reverseString(char *cString)\\
\end{verbatim}
die die Zeichenfolge eines nullterminierten C-String umdreht (\emph{in-place}, d.h. direkt auf dem Speicher, der durch den Pointer designiert wird), dabei aber keine Funktionen aus einer anderen Bibliothek verwendet.
 Überlege dir zunächst, wie du die Länge des C-Strings ermitteln kannst, wenn sie nicht in der Signatur spezifiert wurde.
\begin{verbatim}
  ("Ex25_YourName.cpp")
\end{verbatim}

\textbf{26. Pointer auf pointer}\\
  \begin{enumerate}
  \item 
\begin{verbatim}
void strangeFunction(int **ptrToA);
\end{verbatim}
    Welcher Ausdruck liefert in der Funktion die Adresse der Variablen a, wenn die Funktion mit dem übergebenen Parameter aufgerufen wird?    
\item 
\begin{verbatim}
int array[1000];
\end{verbatim}
  Welche zwei Ausdrücke liefern die Adresse des hundertsten integers im array?
\item 
\begin{verbatim}
int x = 0;
int *ptrX = &x;
int **ptrPtrX = (int**) ptr;
**ptrPtrX = 50;
\end{verbatim}
Was geht hier nach unsauberem Casten garantiert schief?
\item 
\begin{verbatim}
#include <iostream>
using namespace std;

void function(int** const & strangeVar);

int main(){
  int b = 500;
  int *ptr = &b;
  int **ptrPtr = &ptr;
  function(ptrPtr);
}

void function(int** const & strangeVar){
  int value = ???
  int *adress = ???  
  return;
}
\end{verbatim}
% Solution: const-reference on pointer is resolved by the compiler =>
% int value = **strangeVar;
% int *adress = *strangeVar; 
Was muss auf der rechten Seite der assignments in der Funktion stehen, um den Wert bzw. die Adresse von a zu erhalten?

\end{enumerate}
\begin{verbatim}
  ("Ex26_YourName.txt")
\end{verbatim}


\textbf{27. Einfach verkettete Listen}\\
  Eine einfach verkettete Liste ist eine häufig verwendete Datenstruktur. Sie kann z.B. benutzt werden, um ein dynamisches Array zu implementieren, d.h. ein Array, bei dem die Länge zur Laufzeit des Programms verändert werden kann. Eine einfache Implementierung für eine Liste von integern wird durch \texttt{struct}s ermöglicht:

\begin{verbatim}
struct node{
  int value;
  node *next;
};

typedef linkedList node;
\end{verbatim}

Jeder \texttt{node} beinhaltet hier eine Variable des Arraytyps (in diesem Fall integer), sowie einen Pointer, der auf das nächste Element zeigt, d.h. die Speicheradresse des nächsten \texttt{node} enthält. Dieser hat wieder einen Wert und einen pointer auf das nächste Element usw. 
Das letzte Element wird durch einen null-Pointer gekennzeichnet, d.h. der Wert dieser Pointervariablen ist 0x00000000.
Diese Zusammenfassung führt dazu, dass die einzelnen Elemente der List nicht dicht gepackt im Speicher liegen müssen, da über die Speicheradresseninformation auf jedes Element zugegriffen werden kann. Daher können aus dieser Liste Elemente beliebig entfernt oder hinzugefügt werden. Die Listenelemente sollen alle auf dem Heap angelegt werden.
\vspace{2ex}
\\
\includegraphics[width=1.0\linewidth]{./imgs/linkedList.eps}
\vspace{2ex}
\textbf{Aufgabe:} Implementiere eine verkettete Liste mit \texttt{char}s als Typ \texttt{charList}, eine Funktion
\begin{verbatim}
   void append(linkedList charList, char item);
\end{verbatim}
die eine Liste um ein character verlängert und eine Funktion
\begin{verbatim}
   char removeLastItem(charList);
\end{verbatim}
die das letzte \texttt{char} von der Liste wieder entfernt und zurückgibt.
\begin{verbatim}
  ("Ex27_YourName.cpp")
\end{verbatim}

\textbf{28. Perzeptrone}
\begin{verbatim}
  ("Ex27_YourName.cpp")
\end{verbatim}

\subsubsection{Klassen, templates, STL, weiter Algorithmen}

\textbf{28. csv-Dateien und Standardbibliothek}\\
  Templates bieten die Möglichkeit, eine Funktion oder unabhängig von einem bestimmten Datentyp zu implementieren. 
  Dieser wird dann vom Compiler zur Laufzeit eingefügt, und zwar mit dem jeweiligen Datentyp an der verwendeten Stelle, d.h. der verwendete Algorithmus ist unabhängig vom Datentyp verwendbar.
  Eine template-Klasse mit dem template-Typ \texttt{T} wird z.B. folgendermaßen realisiert:
  \begin{verbatim}
  template <typename T>
  class myTempClass {
     public:
     myTempClass(const T &init) : (init) {}      
     T getValue() const;
     void setValue(const T &val) {this->value = val;}
     private:
     T value;
  };
  \end{verbatim}

  Wird diese Klasse nun irgendwo im Quelltext verwendet, muss \texttt{T} an der entsprechenden Stelle spezifiert werden.
  Dies geschieht ebenfalls durch die Angabe eines Datentyps in spitzen Klammern:

  \begin{verbatim}
  int main(){  
  myTempClass<int> intClass(100);
  //.......
  intClass.setValue(5);
  }
  \end{verbatim}
  
  Besonders bietet sich diese Konstruktion für Containerklassen an, d.h. Klassen, die außschließlich dafür gedacht sind, viele Instanzen des gleichen oder verschiedener Datentyp(s/en) zusammenzufassen.
  Solche 
  Als einfachste Beispiel sei hier \texttt{std::vector>} genannt. Diese Klasse wird im Prinzip wie ein array eines bestimmten Typs verwendet. 
  D.h. für Aggregate des gleichen Datentyps in fester Ordnung, numerischen Indices und möglichst fixer Größe. Die Länge eines \texttt{std::vector} kann variiert werden, allerdings ist der dazugehörige Aufwand linear, da die Verlängerung das Kopieren des gesamten Vektors zur Folge haben kann.
  Dafür ist garantiert, dass die eigentlichen Daten kompakt im Speicher liegen, was beispielsweise Kompatibilität zu C-Arrays ermöglicht.
  \texttt{std::vector$<$double$>$} kann als Objekt wie ein array vom Typ \texttt{double} verwendet werden, ist aber in der Handhabung etwas komfortabler, da einige zusätzlichen Funktionen bereitgestellt werden. Einige einfache Beispiele für den Umgang mit den Funktionen von \texttt{std::vector}.

\begin{verbatim}
  unsigned int size = 100;
  vector<double> *v = new vector<double>(size); // create new vector<double>
  double tenthElement = v->at(10);              // read value from vector
  (*v)[10] = 140.0;                                // write element to vector
  unsigned int vLength = v->size();              // get number of elements
  v->push_back(500.0)                            // append element, thereby 
                                                // increasing the length of v by 1
  delete v;                                     // free memory
\end{verbatim}    

  Die STL (Stanadard Template Library) ist ein Bestandteil der C++-Bibliothek und verwendet durchgehend das template-Konstrukt.\\
  Ein sinnvoll einsetzbares Programm sollte in der Lage sein, alle zu verarbeitenden Daten aus Dateien zu lesen. 
  Viele naturwissenschafliche Messdaten können im csv-Format als Tabelle abgespeichert werden. 
  Der typische Aufbau besteht dabei aus einer Kopfzeile mit $n$ Einträgen, die von einem Trennzeichen (``,'', ``\textbackslash t'', ``;'')getrennt werden. In den nächsten Zeilen folgen dann jeweils die Daten.
  Während für das Lesen die C++-Standardbibliothek (oder andere Bibliotheken) recht einfache Funktionen bereitstellt, 
  ist bereits die Interpretation und Umwandlung eines solch einfach aufgebauten Formates keine triviale Aufgabe mehr.  
  Daher übernimmt diese Aufgabe hier die mitgesendete Klasse \texttt{CsvParser}. 
  Diese Klasse aber ist unter keinen Umständen als Beispiel für saubere Programmierung zu verstehen.
  Unter anderem verwendet diese Klasse die beiden Klassen \texttt{std::string} und \texttt{std::vector} der C++-Standardbibliothek. 
  \texttt{std::string} repräsentiert Zeichenketten als Objekte.
  Der \texttt{CsvParser} verwendet den \texttt{typedef vectorMatrix}, der aus Vektoren eine Matrix aufbaut:
\begin{verbatim}
  typedef vector<vector<double> > vectorMatrix;
\end{verbatim}
Wie man sieht, können Templates auch geschachtelt werden.
Auf das Element (5, 10) kann dann z.B. folgendermaßen zugegriffen werden, da der erste Zugriffsoperator jeweils ein Element vom Typ  \texttt{std::vector$<$double$>$}
\begin{verbatim}
  double value = matrix.at(5).at(10);
\end{verbatim}
Oder auch kürzer:
\begin{verbatim}
  double value = matrix[5][10];
\end{verbatim}

In \texttt{main()} befindet sich ein Beispiel, wie diese Klasse nun verwendet werden kann: 
  \begin{itemize}
  \item Anlegen eines Parser-Objekt: Dem Konstruktor muss ein std::string mit dem absoluten Dateipfad übergeben werden, ein char als Trennzeichen und ein Zeichen für den Dezimalpunkt.
  \item Lesen der Datei und Umwandlung der Dateidaten in einen vector mit den Kopfzeileneinträgen und eine Datenmatrix
  \item Zugriff auf die gelesenen Daten durch eine get-Funktionen, die einen pointer liefern.
  \item Lesende Operationen auf den zugänglich gemachten Daten
  \item Aufräumen des Speichers, sobald die Daten nicht mehr benötigt werden.
  \end{itemize}  
  \textbf{Aufgabe:} Erstelle mithilfe dieser Klasse ein Programm, das ein csv-File liest (z.B. das Mitgeschickte), und aus jeder Zeile und jeder Spalte jeweils das arithmetische Mittel berechnet sowie die Matrix transponiert, d.h. Zeilen und Spalten vertauscht.
\begin{verbatim}
  ("Ex28_YourName.cpp")
\end{verbatim}

 \textbf{29. Objektmodellierung}\\ 
  Objekte können ebenfalls eine Klassenvariable darstellen. Durch das Zuweisen von Variablenwerten können Eigenschaften, durch die Implementierung der Funktionen können abgebildet werden.  
  \textbf{Aufgabe:} Modelliere ein beliebiges Tier aus seinen wichtigsten Körperteilen und den dazugehörigen -funktionen.
  Schreibe dazu jeweils nur die Definition der Klassen und mit den dazugehörigen Deklarationen der Funktionen, ohne letztere zu implementieren.  
\begin{verbatim}
  ("Ex29_YourName.cpp")
\end{verbatim}







\begin{minipage}[H]{0.3\linewidth}
\includegraphics[width=\textwidth]{./imgs/ebola}
%\caption{default}
\end{minipage}
\begin{tabular}{m{30em}}
\textbf{30. Binärbäume \& Parser} \\  
Um von der Kommandozeile direkt in einen \texttt{std::string} zu lesen, bietet sich die Funktion \texttt{getline} an:
\end{tabular}
\begin{verbatim}
 #include <iostream>
 #include <string>
 #include <sstream>

 using std::cin;
 using std::string;
 using std::cout;
 using std::endl;

 int main(){
    std::string s;
    getline(cin, s);
    cout << string << endl;
 }
\end{verbatim}
In dieser Aufgabe soll ein Taschenrechner implementiert werden, der folgende Ausdrücke unter Verwendung der 4 Grundrechenarten als Kommandozeileneingabe auslesen und berechnen kann:
\begin{verbatim}
  123.5 + 5 * 2 - 35 / 7
\end{verbatim}
Das Problem besteht nun darin, dass die Operatorpräzedenz und die damit Handlungssequenz dynamisch zur Laufzeit hergeleitet werden muss.
D.h. der Programmierer kennt nicht die Reihenfolge, in der die Rechnungen ausgeführt werden und kann daher nur Regeln beschreiben, nach denen das Programm die Sequenz 

 in der die Rechnungen explizit durchgeführt werden sollen. Kommen mehrere gleichrangige Rechnungen vor, dann ist es auch egal, in welcher Reihenfolge die Rechnungen abgearbeitet werden.
Da die verwendeten mathematischen Ausdrücke nur 2 Argumente verwenden,
kann der Ausdruck z.B. als Binärbaum dargestellt werden. Dabei handelt es sich um eine Datenstruktur, die ein wenig an die bereits behandelte Liste hat.
Jeder ``node'' entspricht dabei einer durchzuführenden Rechenoperation und zeigt dabei entweder auf einen anderen ``node'', d.h. die Operation verwendet das Zwischenergebnis einer anderen Rechnung.
Eine Operation kann auch festgelegte Werte aus dem Ausdruck verwenden.
\\
Beispiel Michaelis-Menten-Kinetik:

\[ v([S]) = \frac{v_{max} \cdot [S]}{K_m + [S]},\]

Diese Formel beschreibt für eine Reihe von Enzymen in guter Näherung die Umsatzgeschwindigkeit $v$ in Abhängigkeit von der Substratkonzentration $v[S]$ und verwendet dazu die zwei Konstanten $K_m$ und $v_{max}$. 
Der entsprechende Parserbaum sähe folgendermaßen aus:
\begin{center}
\includegraphics[width=.5\linewidth]{./imgs/formtree.pdf}
\end{center}

Wird der Baum traversiert, d.h. sukzessive von unten nach oben abgearbeitet, ergibt sich an der root das Ergebnis der Gleichung.
Die Traversierung repräsentiert also genau das Vorgehen, wenn man versuchen würde, die Formel mit gegebenen Werten von Hand zu berechen: 
\begin{itemize}
\item Multipliziere $v_{max}$ und $[S]$.
\item Addiere $K_m$ und $[S]$.
\item Teile das Ergebnis des ersten Schrittes durch das des Zweiten.
\end{itemize}

Will man den Parserbaum für eine gegebene Menge von Operatoren aufstellen, bietet es sich zunächst an, die Baumstruktur analog zu der Liste zu implementieren. 
Ein \texttt{node} kann beispielsweise folgendermaßen konstruiert werden:

\begin{verbatim}
  class ParserTreeNode {
  public:
    ParserTreeNode(const double val);
    ParserTreeNode(const char op, ParserTreeNode *firstChild, ParserTreeNode *secondChild)
    // .......
   double result();

  private:
    const bool isLeaf;
    union nodeData
    {  
       char op;      // is used if node operation   
       double val;   // is used if node is leaf and has a fixed value
    };

    nodeData data;
    ParserTreeNode * firstChild;
    ParserTreeNode * secondChild;
  };
\end{verbatim}

Anschließend sollte der Ausdruck, d.h. mit der niedrigsten Operatorpräzedenz angefangen werden und parallel der Baum von der Wurzel her aufgebaut werden. Ist man bei einema atomaren Ausdruck angekommen, d.h einer Zahl angekommen, wird der \texttt{node} als \texttt{leaf} markiert, und in der \texttt{union} statt einem Operator eine Konstante kodiert. 
Am besten werden gleich zwei Konstruktoren für jeweils der beiden Funktionsweisen des \texttt{node} angelegt.
Die Funktion \texttt{result()} liefert rekursiv das Ergebnis der jeweiligen Operation, d.h. Aufrufen durch die Wurzel liefert das Ergebnis des gesamten Ausdrucks.
Ist der \texttt{node} ein Operator, muss auf die beiden Referenzen (``child nodes'') zurückgegriffen werden und das Ergebnis (gegebenenfalls berechnet werden).
Bei einem \texttt{leaf} wird der Konstantenwert direkt zurückgegeben.\\
Im Grunde handelt es sich bei dem Programm um einen Interpreter für eine eigene kleine Programmiersprache aus 4 Operatoren.
Tatsächlich verwenden auch richtige Compiler eine Art Parserbaum, um den Quelltext des Programmierers auszuwerten und aus den Anweisungen eine Handlungssequenz (in Form von Maschinensprache) abzuleiten.
\begin{verbatim}
  ("Ex30_YourName.cpp")
\end{verbatim}






\begin{minipage}[H]{0.175\linewidth}
\includegraphics[width=\textwidth]{./imgs/dalek}
%\caption{default}
\end{minipage}
\begin{tabular}{m{35em}}
 \textbf{31. Formale Sprachen:}\\
  Sei $\mathcal{S}$ eine rekursiv definierte Sprache über dem Alphabet $\Sigma = \{A, B, C, *, +\}$  mit den atomaren Termen $A, B, C$.\\
  Rekursionsregeln:
\end{tabular}
  \begin{enumerate}
  \item Ist $\phi$ ein gültiger Ausdruck in $\mathcal{S}$, dann ist auch $*\phi$ gültig.
  \item Sind $\phi$ und $\psi$ gültige Ausdrücke, dann ist auch $\phi+\psi$ gültig.   
  \end{enumerate}
 Ausdrücke, die nicht unter Anwendung dieser Regeln gebildet werden können, sind nicht gültig.
  Beispiele:
  \begin{itemize}
  \item $C$ 
  \item $C+B$
  \item $A+*B$
  \item $*****A$
  \item $**B+**C+***B$ 
  \end{itemize}
  sind gültige Ausdrücke in $\mathcal{S}$.
  \begin{itemize}
  \item $ABC$ 
  \item $AB*$ 
  \item $A++C$   
  \end{itemize}
   sind keine gültigen Ausdrücke in $\mathcal{S}$.\\\textsc{
}
  \textbf{Aufgabe:} Entwickle ein Programm, das testet, 
  ob es sich bei dem Inhalt eines \texttt{char []} um einen gültigen Ausdruck handelt.\\
  \textbf{Hinweise zum Aufbau:}\\
  \begin{itemize}
    \item
  Mit dieser zusätzlichen Zeile kann für \texttt{unsigned int} der wesentlich kürzere Name \texttt{uint} definiert werden:
\begin{verbatim}
  //..
  using namespace std;
  typedef unsigned int uint;
  //...
\end{verbatim}
\item
  Header, die solche nützlichen Definitionen enthalten, sind leider nicht immer im C++-Standard enthalten und werden daher durch viele systemspezifische header ergänzt.\\  
\item
  Ein rekursiver Ansatz sollte deutlich leichter sein als der iterative Weg.
\item Die Array-Größe kann als globale Konstante festgelegt werden, da variablen-abhängige Array-Längen nicht durch den C++-Standard unterstützt werden (aber bei \texttt{g++} als Erweiterung mit drin sind.)
\begin{verbatim}
  //..
  using namespace std;
  typedef unsigned int uint;
  const uint strSize = 100;  
  //...function declarations
\end{verbatim}
  Die Implementierung folgender, oder ähnlicher Hilfsfunktionen könnte helfen, das Problem zu lösen und gleichzeitig einen lesbaren Quellcode zu erzeugen:
\end{itemize}
\begin{verbatim}
   /*   Returns if a given term contains a character
   */
  bool contains(char term[], uint termSize, char c);
\end{verbatim}
\newpage
\begin{verbatim}
   /*   Returns if the term contains other characters 
    *   than allowed (i.e other chars than 'A', 'B', 'C', '+' or '*')
    */
  bool containsOnlyValidLetters(char term[], uint termSize);

   /*   Delivers a substring from "input" from "first" two "
    *   The delivered string is well terminated with 0x00. However, its 
    *   allocated space is equal to the size of the input string.
    *   Returns if extraction was possible within the size parameters.
    *   Example: "ABCDEFGHIJK\0" => first = 1, last = 4 ====> "BCDE\0"
    */
  bool substring(char input[], char result[], uint &resultSize, uint first, uint last);

   /*   Returns if the given substring is valid 
    *   by checking the recursion rules
    *   Recursive function.
    */
  bool isValidTerm(char term[], uint termSize);

   /*   Returns if the given term is atomic
    */
  bool isAtomicTerm(char term[], uint termSize);
\end{verbatim}

Insgesamt sieht der Ansatz also so aus (für Ausdrück mit maximal 99 Zeichen):

\begin{verbatim}
  #include <iostream>
  using namespace std;
  typedef unsigned int uint;
  const uint strSize = 100;

  bool contains(char term[], uint termSize, char c);
  bool containsOnlyValidLetters(char term[], uint termSize);
  bool substring(char input[], char result[], uint &resultSize, uint first, uint last);
  bool isValidTerm(char term[], uint termSize);
  bool isAtomicTerm(char term[], uint termSize);

  int main(){
    main
  }
\end{verbatim}
\begin{verbatim}
  ("Ex31_YourName.cpp")
\end{verbatim}

\textbf{32. Von Stapeln und Haufen}\\
\begin{verbatim}
  ("Ex32_YourName.cpp")
\end{verbatim}

\textbf{33. Graphische Oberflächen mit QT:}\\
\begin{verbatim}
  ("Ex32_YourName.cpp")
\end{verbatim}

\textbf{33. OpenGL:}\\
\begin{verbatim}
  ("Ex34_YourName.cpp")
\end{verbatim}

\textbf{35. Neuronale Netzwerke:}\\
\begin{verbatim}
  ("Ex35_YourName.cpp")
\end{verbatim}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
